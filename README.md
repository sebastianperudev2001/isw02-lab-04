# isw02-lab-04

Lab 04: Patrones de comportamiento

Elaborado por: Sebasti√°n Ch√°varry

Temas a tratar:

- Strategy

# Command

- Prop√≥sito: Convertir una solicitud (payload) en un objeto independiente para facilitar la ejecuci√≥n de m√©todos.
  > En sencillo: Command es la capa intermedia entre tu UI y tu l√≥gica de negocio

## ¬øC√≥mo lo pueden implementar en su proyecto?

1. Job Queue: Para procesar tareas en segundo plano (enviar mails, generar PDFs, hacer c√°lculos pesados)
2. Auditor√≠a y trazabilidad: Registrar qu√© acciones se ejecutaron en el sistema, cu√°ndo y c√≥mo.
3. Reintentos: Reintentar tareas que fallaron como enviar SMS, confirmar pagos, llamar a APIs externas.
4. Testing: Poder testear acciones de negocio desacopladas de sus invocadores.
5. Implementar UNDO/REDO: Interfaces que permiten revertir acciones, como en editores o apps de dise√±o.
6. Orquestar workflows/pipelines: Ejecutar una secuencia ordenada de pasos (por ejemplo, un flujo de onboard de cliente).
7. Control de permisos por tipo de acci√≥n: Aplicaciones con reglas de negocio complejas.
8. Intercambio de acciones entre microservicios: Comunicar servicios desacoplados mediante eventos o comandos serializados.

# ¬øC√≥mo implementarlo?

## üõí Caso de uso (texto):

> En un ecommerce, los clientes pueden realizar acciones como **agregar productos al carrito**, **remover productos** o **vaciar el carrito**. Cada acci√≥n debe encapsularse como un comando para que pueda registrarse, deshacerse o incluso ejecutarse de manera asincr√≥nica en el futuro (por ejemplo, en un flujo de checkout).

---

### ‚úÖ Paso 1: Interfaz de comando con un √∫nico m√©todo de ejecuci√≥n

```java
public interface Comando {
    // Solo tiene un m√©todo
    void ejecutar();
}
```

---

### ‚úÖ Paso 2: Receptor y comandos concretos

Empieza extrayendo solicitudes y poni√©ndolas dentro de clases concretas de comando que implementen la interfaz de comando. Cada clase debe contar con un grupo de campos para almacenar los argumentos de las solicitudes junto con referencias al objeto receptor. Todos estos valores deben inicializarse a trav√©s del constructor del comando.

```java
// Receptor
public class Carrito {
    public void agregarProducto(String producto) {
        System.out.println("Producto agregado: " + producto);
    }

    public void removerProducto(String producto) {
        System.out.println(" Producto removido: " + producto);
    }

    public void vaciar() {
        System.out.println("Carrito vaciado.");
    }
}

// Comando concreto para agregar
public class ComandoAgregarProducto implements Comando {
    private Carrito carrito;
    private String producto;

    public ComandoAgregarProducto(Carrito carrito, String producto) {
        this.carrito = carrito;
        this.producto = producto;
    }

    @Override
    public void ejecutar() {
        carrito.agregarProducto(producto);
    }
}

// Comando concreto para remover
public class ComandoRemoverProducto implements Comando {
    private Carrito carrito;
    private String producto;

    public ComandoRemoverProducto(Carrito carrito, String producto) {
        this.carrito = carrito;
        this.producto = producto;
    }

    @Override
    public void ejecutar() {
        carrito.removerProducto(producto);
    }
}

// Comando concreto para vaciar
public class ComandoVaciarCarrito implements Comando {
    private Carrito carrito;

    public ComandoVaciarCarrito(Carrito carrito) {
        this.carrito = carrito;
    }

    @Override
    public void ejecutar() {
        carrito.vaciar();
    }
}
```

---

### ‚úÖ Paso 3: Emisora (el sistema que dispara el comando)

Identifica clases que act√∫en como emisoras. A√±ade los campos para almacenar comandos dentro de estas clases. Las emisoras deber√°n comunicarse con sus comandos tan solo a trav√©s de la interfaz de comando. Normalmente las emisoras no crean objetos de comando por su cuenta, sino que los obtienen del c√≥digo cliente.

```java
public class BotonAccionCarrito {
    private Comando comando;

    public BotonAccionCarrito(Comando comando) {
        this.comando = comando;
    }

    public void presionar() {
        comando.ejecutar();
    }
}
```

---

### ‚úÖ Paso 4: Cliente (inicializa y ejecuta)

Cambia las emisoras de forma que ejecuten el comando en lugar de enviar directamente una solicitud al receptor.

```java
public class Main {
    public static void main(String[] args) {
        // Receptor
        Carrito carrito = new Carrito();

        // Comandos
        Comando agregarLaptop = new ComandoAgregarProducto(carrito, "Laptop Gamer");
        Comando removerLaptop = new ComandoRemoverProducto(carrito, "Laptop Gamer");
        Comando vaciarCarrito = new ComandoVaciarCarrito(carrito);

        // Emisores
        BotonAccionCarrito botonAgregar = new BotonAccionCarrito(agregarLaptop);
        BotonAccionCarrito botonRemover = new BotonAccionCarrito(removerLaptop);
        BotonAccionCarrito botonVaciar = new BotonAccionCarrito(vaciarCarrito);

        // Ejecutar comandos
        botonAgregar.presionar();
        botonRemover.presionar();
        botonVaciar.presionar();
    }
}
```

---

### ‚úÖ Salida esperada:

```
 Producto agregado: Laptop Gamer
 Producto removido: Laptop Gamer
 Carrito vaciado.
```

# Iterator

- Prop√≥sito: Permitirte recorrer una colecci√≥n (como una lista o conjunto) paso a paso, sin tener que saber c√≥mo est√° construida internamente.

> En sencillo: Quiz√°s tengas conjuntos de datas en listas, binary trees, etc. Entonces, creamos una clase que permita extraer esa l√≥gica de comportamiento de recorrido y lo colocamos en un objeto **_iterator_**.

## üß† Caso de Estudio

> Somos una empresa educativa que ofrece recursos: **libros** y **podcasts**.
> Queremos que el cliente pueda recorrer ambos **sin saber c√≥mo se almacenan internamente**, usando un iterador uniforme.

---

### ‚úÖ 1. **Declara la interfaz iteradora.**

Como m√≠nimo, debe tener un m√©todo para extraer el siguiente elemento de una colecci√≥n. Por conveniencia, puedes a√±adir un par de m√©todos distintos, como para extraer el elemento previo, localizar la posici√≥n actual o comprobar el final de la iteraci√≥n.

```java
public interface Iterador<T> {
    boolean tieneSiguiente();
    T siguiente();
}
```

---

### ‚úÖ 2. **Declara la interfaz de colecci√≥n**

Debe incluir un m√©todo para crear un iterador. El tipo de retorno debe ser igual al de la interfaz iteradora. Puedes declarar m√©todos similares si planeas tener varios grupos distintos de iteradores.

```java
public interface Coleccion<T> {
    Iterador<T> crearIterador();
}
```

---

### ‚úÖ 3. **Implementa clases iteradoras concretas.**

Cada iterador se asocia a una colecci√≥n espec√≠fica y la recorre. Un objeto iterador debe estar vinculado a una √∫nica instancia de la colecci√≥n. Normalmente, este v√≠nculo se establece a trav√©s del constructor del iterador.

#### üìö `IteradorBiblioteca` para libros:

```java
public class IteradorBiblioteca implements Iterador<Libro> {
    private Biblioteca biblioteca;
    private int posicion = 0;

    public IteradorBiblioteca(Biblioteca biblioteca) {
        this.biblioteca = biblioteca;
    }

    @Override
    public boolean tieneSiguiente() {
        return posicion < biblioteca.getLibros().size();
    }

    @Override
    public Libro siguiente() {
        return biblioteca.getLibros().get(posicion++);
    }
}
```

#### üéß `IteradorPodcast` para episodios:

```java
public class IteradorPodcast implements Iterador<Podcast> {
    private PlataformaPodcasts plataforma;
    private int posicion = 0;

    public IteradorPodcast(PlataformaPodcasts plataforma) {
        this.plataforma = plataforma;
    }

    @Override
    public boolean tieneSiguiente() {
        return posicion < plataforma.getPodcasts().size();
    }

    @Override
    public Podcast siguiente() {
        return plataforma.getPodcasts().get(posicion++);
    }
}
```

---

### ‚úÖ 4. **Implementa la interfaz de colecci√≥n.**

Las colecciones (Biblioteca y PlataformaPodcasts) implementan `Coleccion<T>` y devuelven su iterador correspondiente.

#### üìö Clase `Biblioteca`

```java
import java.util.ArrayList;
import java.util.List;

public class Biblioteca implements Coleccion<Libro> {
    private List<Libro> libros = new ArrayList<>();

    public void agregarLibro(Libro libro) {
        libros.add(libro);
    }

    public List<Libro> getLibros() {
        return libros;
    }

    @Override
    public Iterador<Libro> crearIterador() {
        return new IteradorBiblioteca(this);
    }
}
```

#### üéß Clase `PlataformaPodcasts`

```java
import java.util.ArrayList;
import java.util.List;

public class PlataformaPodcasts implements Coleccion<Podcast> {
    private List<Podcast> podcasts = new ArrayList<>();

    public void agregarPodcast(Podcast p) {
        podcasts.add(p);
    }

    public List<Podcast> getPodcasts() {
        return podcasts;
    }

    @Override
    public Iterador<Podcast> crearIterador() {
        return new IteradorPodcast(this);
    }
}
```

---

### ‚úÖ 5. **Repasa el c√≥digo cliente.**

El cliente no se preocupa por c√≥mo est√° implementada cada colecci√≥n. Solo pide un iterador.

```java
public class Main {
    public static void main(String[] args) {
        // Crear colecciones
        Biblioteca biblioteca = new Biblioteca();
        biblioteca.agregarLibro(new Libro("Clean Code"));
        biblioteca.agregarLibro(new Libro("Design Patterns"));

        PlataformaPodcasts plataforma = new PlataformaPodcasts();
        plataforma.agregarPodcast(new Podcast("Java Talks"));
        plataforma.agregarPodcast(new Podcast("Arquitectura Moderna"));

        // Recorrer libros
        System.out.println("üìö Libros:");
        Iterador<Libro> itLibros = biblioteca.crearIterador();
        while (itLibros.tieneSiguiente()) {
            System.out.println("- " + itLibros.siguiente().getTitulo());
        }

        // Recorrer podcasts
        System.out.println("\nüéß Podcasts:");
        Iterador<Podcast> itPods = plataforma.crearIterador();
        while (itPods.tieneSiguiente()) {
            System.out.println("- " + itPods.siguiente().getNombre());
        }
    }
}
```

---

### üì¶ Clases de modelo (Libro y Podcast)

```java
public class Libro {
    private String titulo;

    public Libro(String titulo) {
        this.titulo = titulo;
    }

    public String getTitulo() {
        return titulo;
    }
}
```

```java
public class Podcast {
    private String nombre;

    public Podcast(String nombre) {
        this.nombre = nombre;
    }

    public String getNombre() {
        return nombre;
    }
}
```

---

### ‚úÖ Salida esperada

```
üìö Libros:
- Clean Code
- Design Patterns

üéß Podcasts:
- Java Talks
- Arquitectura Moderna
```
